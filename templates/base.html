<!-- templates/base.html -->
{% load static %}

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Willx</title>

    <!-- CSS -->
    <link rel="stylesheet" href="{% static 'css/style.css' %}">

    <!-- Scripts principaux -->
    <script src="{% static 'js/script.js' %}" defer></script>

  
</head>
<style>
    
    
    body{
    
    padding: 1.1rem 1rem;
    
  }
</style>

<body><!-- HERO HEADER -->


<header id="hero-header" classe="hero-header">
  {% include 'partials/hero-header.html' with is_own_profile=False %}
</header>

<style>
    .profile-stats {
  margin-top: 1rem;
  display: flex;
  justify-content: center; /* centré */
  gap: 2rem;               /* espace entre stats */
  font-size: 0.95rem;
  color: #fff;
  opacity: 0.9;
}

.stat {
  display: flex;
  align-items: center;
  gap: 0.4rem;
}

.stat .icon {
  width: 20px;
  height: 20px;
}
</style>

<!-- STICKY HEADER -->
<header id="sticky-header">
  <div class="sticky-inner">
    <h2 class="logo">
        
      {% block header_title %} <button class="circle-button"></button>Willx{% endblock %}
    </h2>
    <nav class="header-actions">
      {% if user.is_authenticated %}
      {% block deconnexion %} 
      
      
      
  
  
      <div class="profil-header-container">
       <a href="{% url 'user-profile' username=user.username %}">
    <div class="profile-photo small">
        {% if user.profile_photo %}
        
            <img src="{{ user.profile_photo.url }}" alt="{{ user.username }}’s avatar" loading="lazy">
        {% else %}
            <img src="{% static 'icons/default_profile.png' %}" alt="Avatar par défaut" loading="lazy">
        {% endif %}
    </div>
</a></div>
                        
                        
      {% endblock %}
         
      {% else %}
     
        <a href="{% url 'login' %}" class="btn connexion">Se connecter</a>
       
        
          
          <a href="{% url 'signup' %}" class="btn primary deconnexion">S'inscrire</a>
      {% endif %}
    </nav>
  </div>
</header>

<style>
  



  /* Conteneur profil */
  .profil-header-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  /* Photo de profil réduite */
  .profil-header-container .profile-photo.small {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    overflow: hidden;
    
  }

  .profil-header-container .profile-photo.small img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }


</style>
<style>
 /* ================= HERO HEADER ================= */
#hero-header, #hero-header-user-profil {
  position: relative;
  top: 0;
  left: 0;
  right: 0;

  height: 340px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 2rem 1.5rem;

  background: var(--card);
  color: #fff;

  border-radius: var(--radius);
  box-shadow: 0 8px 20px rgba(0,0,0,0.16);
}

.hero-inner {
  width: 100%;
  max-width: 1100px;
  display: flex;
  flex-direction: column; /* vertical */
  align-items: center;    /* centre horizontalement */
  justify-content: center;
  text-align: center;
  gap: 1rem;
}

.brand h1 {
  margin: 0;
  font-size: 2.4rem;
  font-weight: 800;
  line-height: 1.2;
}

.profile-photo {
  width: 140px;
  height: 140px;
  border-radius: 50%;
  overflow: hidden;
  box-shadow: 0 6px 20px rgba(0,0,0,0.25);
border: 2px solid var(--accent);
  margin: 0 auto;  
}
.profile-photo img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.lead {
  padding-left: 23px;
  font-size: 1.1rem;
  opacity: 0.9;
  max-width: 680px;
  margin: 0 auto; /* centre horizontalement le bloc */
}

/* ================= STICKY HEADER ================= */
#sticky-header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 100px;
  z-index: 1000;
padding: 0.5rem 1rem;
  display: flex;
  align-items: center;
  justify-content: center;

  background: rgba(17,24,39,0.9); /* #111827 */
  color: #fff;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);

  opacity: 0;
  pointer-events: none;
  transform: translateY(-8px);
  transition: opacity 0.25s ease, transform 0.25s ease;
}

#sticky-header.visible {
  opacity: 1;
  pointer-events: auto;
  transform: translateY(0);
}

.sticky-inner {
  width: 100%;
  max-width: 1100px;
  display: flex;
  align-items: center;
  justify-content: space-between; /* logo à gauche / boutons à droite */
  padding: 0 1rem;
}

.logo{

  margin: 0;
  font-size: 1.2rem;
  font-weight: 100;
}



.header-actions {
  display: flex;
  gap: .5rem; /* boutons côte à côte */
}

.btn {
  text-decoration: none;
  padding: 0.45rem 0.9rem;
  border-radius: 8px;
  background: rgba(255,255,255,0.1);
  color: #fff;
  font-weight: 500;
  transition: background .2s, transform .2s;
}

.btn:hover {
  background: rgba(255,255,255,0.2);
  transform: translateY(-2px);
}

.btn.primary {
  background: #2563eb;
}

/* ================= RESPONSIVE ================= */
@media (max-width: 768px) {
  #hero-header {
    height: auto;
    padding: 2rem 1rem;
  }

  .brand h1 {
    font-size: 2rem;
  }

  .profile-photo {
    width: 110px;
    height: 110px;
  }

  .lead {
    font-size: 1rem;
    max-width: 90%;
  }

  .sticky-inner {
    padding: 0 .5rem;
  }
}
</style>

<script>
  const hero = document.getElementById('hero-header');
  const sticky = document.getElementById('sticky-header');

  const observer = new IntersectionObserver(([entry]) => {
    if (!entry.isIntersecting) {
      sticky.classList.add('visible');
    } else {
      sticky.classList.remove('visible');
    }
  }, { threshold: 0 });

  observer.observe(hero);
</script>
  
<main>
   {% block content %}{% endblock content %} 
</main>

<!-- ================================
     SCRIPT RIPPLE + CLICK SIMULATION
================================ -->
<script>
(function(){
    // Helper pour navigation programmatique
    function triggerNavigation(el) {
        const href = el.getAttribute && el.getAttribute('href');
        if (!href) return;
        setTimeout(() => {
            if (el.target === '_blank') window.open(href, '_blank');
            else window.location.href = href;
        }, 140);
    }

    const events = ['mousedown', 'pointerdown', 'touchstart'];
    let touchStartX = 0, touchStartY = 0;

    function createRipple(el, clientX, clientY) {
        const computed = getComputedStyle(el);
        if (computed.position === 'static') el.style.position = 'relative';
        if (computed.overflow !== 'hidden') el.style.overflow = 'hidden';

        const rect = el.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height) * 2;

        const ripple = document.createElement('span');
        ripple.className = 'ripple';
        ripple.style.width = ripple.style.height = size + 'px';
        ripple.style.left = (clientX - rect.left - size/2) + 'px';
        ripple.style.top  = (clientY - rect.top  - size/2) + 'px';
        el.appendChild(ripple);

        ripple.addEventListener('animationend', () => {
            if (ripple.parentNode) ripple.remove();
        });
        setTimeout(() => { if (ripple.parentNode) ripple.remove(); }, 900);
    }

    function handleDown(e) {
        if (e.type === 'mousedown' && e.button !== 0) return;

        const el = e.target.closest('a, button');
        if (!el) return;

        // NE PAS appliquer le ripple sur le bouton like
        if (el.classList.contains('like-btn')) return;

        if (e.type === 'touchstart') {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;

            const touchEndHandler = function(ev) {
                const dx = Math.abs(ev.changedTouches[0].clientX - touchStartX);
                const dy = Math.abs(ev.changedTouches[0].clientY - touchStartY);
                if (dx < 10 && dy < 10) createRipple(el, touchStartX, touchStartY);
                el.removeEventListener('touchend', touchEndHandler);
            };
            el.addEventListener('touchend', touchEndHandler);
            return;
        }

        // Ripple pour les autres boutons / liens
        createRipple(el, e.clientX, e.clientY);

        // Click simulé
        if (el.tagName.toLowerCase() === 'a') {
            triggerNavigation(el);
        } else {
            setTimeout(() => el.click(), 140);
        }
    }

    events.forEach(evt => document.addEventListener(evt, handleDown, { passive: true }));
})();
</script>
<style>
/* Assure une transition douce (mettre dans ton CSS global si tu préfères) */
.auto-resize-content {
  transition: height 120ms ease;
  overflow: hidden;
  resize: none;
}
</style>

<script>
(function(){
  'use strict';

  function findTextarea() {
    let ta = document.getElementById('id_content');
    if (ta) return ta;
    ta = document.querySelector('textarea[name="content"]');
    if (ta) return ta;
    ta = document.querySelector('.blog-photo-form textarea');
    if (ta) return ta;
    return document.querySelector('textarea');
  }

  function getNumericStyle(el, prop) {
    return parseFloat(getComputedStyle(el)[prop]) || 0;
  }

  function oneLineHeight(textarea) {
    const computed = getComputedStyle(textarea);
    // calculer hauteur d'une ligne en px (fallback sur fontSize * 1.2)
    const lh = parseFloat(computed.lineHeight) || parseFloat(computed.fontSize) * 1.2;
    const pad = getNumericStyle(textarea, 'paddingTop') + getNumericStyle(textarea, 'paddingBottom');
    return Math.round(lh + pad);
  }

  function applyOneLine(textarea) {
    const h = oneLineHeight(textarea);
    textarea.style.height = h + 'px';
  }

  function applyAutoHeight(textarea, animate = true) {
    if (!textarea) return;
    // add helper class for transition
    textarea.classList.add('auto-resize-content');

    // reset to auto to compute scrollHeight reliably
    textarea.style.height = 'auto';
    const target = textarea.scrollHeight;

    if (!animate) {
      textarea.style.height = target + 'px';
      return;
    }

    // Start from 1-line to allow smooth transition
    applyOneLine(textarea);

    // next frame -> set target height (browser will animate thanks to transition)
    requestAnimationFrame(() => {
      // force reflow
      /* eslint-disable no-unused-expressions */
      textarea.offsetHeight;
      textarea.style.height = target + 'px';
    });
  }

  function attach(textarea) {
    if (!textarea) return false;
    // ensure no vertical scrollbar
    textarea.style.overflow = 'hidden';
    textarea.style.resize = 'none';
    // init state: if empty -> one line, else animate to content but without big jump
    if (textarea.value && textarea.value.trim() !== '') {
      // animate from one-line to content height
      applyAutoHeight(textarea, true);
    } else {
      // keep a single-line height
      applyOneLine(textarea);
      // still attach listener so it will grow when typing
    }

    // listeners
    const resizeNow = () => {
      // when content changes, go to auto height instantly (no abrupt jump)
      textarea.style.height = 'auto';
      textarea.style.height = textarea.scrollHeight + 'px';
    };

    textarea.addEventListener('input', () => window.requestAnimationFrame(resizeNow), { passive: true });
    textarea.addEventListener('paste', () => window.requestAnimationFrame(resizeNow));
    textarea.addEventListener('drop', () => window.requestAnimationFrame(resizeNow));

    return true;
  }

  function initOnce() {
    const ta = findTextarea();
    if (!ta) return false;
    attach(ta);
    return true;
  }

  document.addEventListener('DOMContentLoaded', () => {
    if (initOnce()) return;

    // si le textarea est injecté plus tard (ex: forms renderés dynamiquement), observe le DOM
    const mo = new MutationObserver((mutations, observer) => {
      if (initOnce()) observer.disconnect();
    });
    mo.observe(document.body, { childList: true, subtree: true });

    // safety timeout: arrêter l'observer après 5s
    setTimeout(() => mo.disconnect(), 5000);
  });

  // export function to re-init manually if needed
  window.__initAutoResizeContent = initOnce;
})();
</script>
</body>
</html>
